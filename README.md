# Библиотека для обработки исходных данных сигналов акустических источников

**Библиотека для обработки исходных данных сигналов акустических источников** – набор инструментов, который позволяет проводить предварительную обработку и суммирование исходных акустических распределённых сигналов (в том числе от пневматических источников). Программные компоненты модуля позволяют различными методами провести предварительную фильтрацию исходных распределенных сигналов и рассчитать итоговый сигнал в заданной точке пространства, с учетом его затухания и отражения.

![Logotype](./docs/НТИ_логотип_с_плашкой_RGB.png)

## Установка

Установка не предполагается.

<!---
## Разработка

Разработка UI приветствуется.
-->

### Сборка

Используется система сборки CMake.

Главный файл находится в каталоге `app\gund_solvers`.

Для сборки тестов указывается опция `WITH_TESTS`.

Используемые сторонние библиотеки:
- [nlohmann](https://github.com/nlohmann/json/releases/)
- [Simple-FFT](https://github.com/d1vanov/Simple-FFT)


## Функциональность

Учтено отражение от водной поверхности.

Исходные акустические распределённые сигналы зачитываются из файлов `*.sig`.

Поддерживаются различные варианты предварительной фильтрации исходных распределенных сигналов.

## Использование

Для организации предварительной подготовки и суммирования исходных акустических распределенных сигналов (в том числе от пневматических источников), следует корректно сформировать входные данные для модели. Для упрощенного использования библиотеки заполнение производится в файл .json определенного вида.
### Подготовка входных данных
Входные данные должны включать информацию об источнике распределенных сигналов: имя, тип источника, его расположение в декартовых координатах (м), объем (cuin) и давление (psi) внутри камеры источника, коэффициент заполнения камеры и температуру (С).
Пример входных данных для одного источника представлен ниже:
```
"gunArray": [
		{
			"name": 0,
			"type": "1500C",
			"coordinate": {
				"x": 0.0,
				"y": 0.0,
				"z": 6.0
			},
			"volume": 100.0,
			"pressure": 2000.0,
			"shapeRatio": 1.0,
			"temperature": 0
		}
	]
```
Заполнение свойств среды включает информацию о скорости звука (м/с) и температуре в среде (С):
```
"physicalParameters": {
		"temperature": 0,
		"soundVelocity": 1496.0
	}
```
Генерация сигнала может включать отражение от поверхности, заданное значением коэффициента отражения в промежутке от -1 до 0, и изменение координат точки наблюдения (при желании задать соответствующие координаты требуется выбрать режим `"infiniteType": false`):
```
"reflection": {
		"coeff": 0.0
	},
"observationPoint": {
		"infiniteType": true,
		"coordinate": {
			"x": null,
			"y": null,
			"z": null
		}
	}
```
Параметры генерации итогового сигнала, такие как величина шага по времени (с) и количество отсчетов должны быть заданы в формате:
```
"sigParams": {
		"sampleInterval": 0.0005,
		"sampleNum": 1000
	}
```
При желании использовать фильтр, его характеристика должна быть помещена в каталог `data`, а название прописано в соответствующей строке .json:
```
"filter": {
		"accessMode": "EXTERNAL",
		"filename": "filtername.flt"
	}
```
Пример заполнения входных данных находится в каталоге `test\spectrum_solver_test\test_data`.
### Применение модели
Применение модели основано на использовании общего класса с несколькими открытыми пользователю функциями. Рассмотрим подробнее.
##### Получение входных данных
Для упрощенного взаимодействия с библиотекой присутствует функция `parseInitJson()`, автоматически читающая в заполненный ранее .json файл параметры `params` и `options`:
```
std::string json = "start_file.json";
SpectrumSolverParams params;
SpectrumSolverOptions options;
parseInitJson(json, params, options);
```
##### Суммирование и обработка исходных акустооптических распределенных сигналов
Для создания модели используется класс `SpectrumSolver`, предполагающий заполнение адреса расположения файлов с предподготовленными сигнатурами единичных источников, в данном примере обозначенного с помощью строки `dataPath`:
```
SpectrumSolver solver(params, options);
solver.setDataPath(dataPath);
```
Применение модели зависит только от входных параметров, таких как коэффициент отражения, наличие фильтрации и т.д. Поэтому применение модели возможно с помощью функции `solve`:
```
solver.solve();
```
##### Диаграммы направленности
Диаграмма направленности системы пневмоисточников представляет собой зависимость амплитуды (дБ) итогового акустического поля в частотной области от частоты $$f$$ и полярного угла $$\theta$$ сферической системы координат (отметим, что ось $$Ox$$ направлена против движения корабля-носителя, а ось $$Oy$$ в направлении морского дна). По ней можно судить о том, в каком направлении распространяется наиболее интенсивный сигнал. Для построения диаграммы направленности используется класс `Diagram`, конструктор которого принимает на вход структуры `DiagramParams, DiagramOptions`:

```
struct DiagramParams {
    std::vector<DelayedGun> gunArray;
    gund_structs::PhysicalParameters physParams;
};

struct DiagramOptions {
    gund_structs::Reflection reflection;
    gund_structs::Filter filter;
    gund_structs::SignatureParameters sigParams;
};
```

Здесь допускаются источники с заданной задержкой `delay` момента запуска:
```
struct DelayedGun : gund_structs::Gun {
    double delay;
};
```
Вывод результатов построения диаграммы направленности осуществляется в json-файл в табличном виде при помощи метода `outputDiagram`, аргументом которого является структура `OutputDiagramOptions` с настраиваемыми параметрами вывода:
```
struct OutputDiagramOptions {
    enum Bearing { INLINE, CROSSLINE };

    std::string outputFileName;
    Bearing bearing;
    double azimut;
    double angleMeshStep;
    double freqMeshStep = 1.95312;
    size_t angleMeshSize = 180;
    size_t freqMeshSize = 130;
};
```
Диаграммы направленности различаются по выбору плоскости азимутального угла $$\phi$$ (он же `azimut`) сферической системы координат. Имеется два базовых случая: `INLINE: azimut == 0` -- продольный, и `CROSSLINE: azimut == -pi/2` -- поперечный.
![базовые случаи](./docs/base.png)
На картинке ниже приведен пример отрисовки продольной и поперечной диаграмм направленности для системы из двух пневмоисточников. Отрисовка производилась средствами Wolfram Mathematica.
![пример](./docs/example.png)
Также создавать и выгружать диаграммы направленности можно из класса `SpectrumSolver` при помощи метода `computeDiagrams`. При таком подходе будут использованы полученные ранее [входные данные](#получение-входных-данных) о сборке пневмоисточников из json-файла.

##### Энергетические величины
В классе `Energy` производится расчет таких характеристик, как энергетический центр системы пневмоисточников, полная акустическая энергия, индивидуальный акустический вклад источника, полная потенциальная энергия и акустический КПД системы. Полная потенциальная энергия представляется суммой $$E_\text{potential}=\sum p_i V_i$$ по всем пневмоисточникам внутренних энергий содержащегося в них газа до запуска процесса эмиссии. Затем каждый из источников вносит свой вклад $$E_i$$ в полную акустическую энергию $$E_\text{acoustic}=\sum E_i$$ создаваемого в воде поля давления. При формировании акустического поля происходит попарное взаимодействие между источниками, которое влияет на их индивидуальные вклады $$E_i$$. В результате такого взаимодействия может даже оказаться, что некоторые из вкладов окажутся отрицательными. Однако это не означает, что соответствующие пневмоисточники в системе являются лишними, -- скорее наоборот, они выступают в роли катализаторов, усиливая энергетические вклады от других источников. Энергетический центр представляет собой точку, задаваемую радиус-вектором $$\sum \frac{E_i}{E_\text{acoustic}}\textbf{r}_ i$$, где $$\textbf{r}_ i$$ -- радиус-векторы пневмоисточников. КПД акустического поля определяется отношением $$E_\text{acoustic} / E_\text{potential}$$.\
Конструктор класса `Energy` принимает на вход структуры `EnergyParams, EnergyOptions`. В результате формируется структура `EnergyResult`:
```
struct EnergyResult {
    std::vector<double> energy;
    struct { double x, y, z; } energyCenter;
    double totalAcousticEnergy;
    double totalPotentialEnergy;
    double acousticEnergyEffectiveness;
};
```
Для включения полученных данных в итоговый отчет на основе [входных данных](#получение-входных-данных) в классе `SpectrumSolver` предусмотрен метод `computeEnergyParams`.

##### Выгрузка результатов
Результаты моделирования всех доступных в библиотеке данных хранятся в параметре `result`:
```
auto result = solver.solve();
```
В случае возникновения ошибок во время моделирования соответствующее сообщение будет выгружено пользователю в параметр `result`. Для обработки таких событий рекомендуется использовать конструкцию:
```
auto result = solver.solve();
if (std::holds_alternative<SpectrumResult>(result)) {
    auto& res = std::get<SpectrumResult>(result)
}
else {
    auto& strError = std::get<std::string>(result)
} 
```
При корректных входных данных параметр `res` из примера выше содержит в себе значения результирующего сигнала `res.signal` и амплитуды спектральной характеристики `res.ampSpec`, амплитуда выражена в дБ. Также, можно получить информацию об индивидуальных вкладах источников сигнала `res.singleContrib`, характеризующую как энергетические, так и вклады по приросту давления. Значения инженерных параметров находятся в параметре `res.rParams` и включают величины, такие как peak-to-peak (выраженное в бар и дБ), zero-to-peak, bubble-period (с) и другие, а также упомянутые ранее центры энергии и давления и геометрический центр. 
Дополнительные комментарии, возникшие в ходе выполнения конкретной модели, можно получить, вызвав функцию:
```
solver.getMessages();
```

## Благодарности

Работа выполнена Инжиниринговым центром по трудноизвлекаемым полезным ископаемым Центра компетенций НТИ на базе МФТИ по направлению "Искусственный интеллект" в рамках "дорожной карты" развития высокотехнологичного направления "Искусственный интеллект" на период до 2030 года при поддержке Фонда НТИ.

<!---
## Авторы
-->

## Contributing

Комментарии и улучшения приветствуются.

<!---
## Links

- Project homepage: 
- Repository: 
- Related projects:
-->

## Лицензия

Распространяется по лицензии BSD 3-Clause.
